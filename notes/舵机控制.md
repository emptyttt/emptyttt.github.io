# 舵机商家代码（旧）

| id   | 宏名   | 实际引脚 |
| :--- | :----- | :------- |
| 1    | SERVO1 | PC10     |
| 2    | SERVO2 | PC11     |
| 3    | SERVO3 | PC12     |
| 4    | SERVO4 | PD2      |
| 5    | SERVO5 | PB5      |
| 6    | SERVO6 | PB8      |

| 脉宽(us) | 角度(°) |
| :------- | :------ |
| 500      | 0       |
| 1000     | 45      |
| 1500     | 90      |
| 2000     | 135     |
| 2500     | 180     |

舵机控制

控制1路舵机

```C
	while(1)
	{
		
		while(1)
		{
			TaskTimeHandle();
			if(ServoAction())
				continue;
			i+=20;
			ServoSetPluseAndTime(5,i,100);
			if(i>=1800)
				break;
		}
		while(1)
		{
			TaskTimeHandle();
			if(ServoAction())
				continue;
			i-=20;
			ServoSetPluseAndTime(5,i,100);
			if(i<=500)
				break;
		}
		TaskTimeHandle() ;
		
	}
```

# 新版代码

## 舵机测试

放在while前

```C
// 舵机测试代码 - 测试上下舵机是否正常
    // 测试序列：0度 -> 135度(中心) -> 270度 -> 135度(中心)
    
    // 第一阶段：测试上方舵机
    OLED_Clear();
    OLED_ShowString(1, 1, "Test Above Servo");
    
    Servo_SetAngle(SERVO_ABOVE, 0, 2000);    // 0度位置，2秒
    for(int i = 0; i < 100; i++) { Servo_UpdatePosition(SERVO_ABOVE); Delay_ms(20); }
    
    Servo_SetAngle(SERVO_ABOVE, 135, 2000);  // 中心位置，2秒
    for(int i = 0; i < 100; i++) { Servo_UpdatePosition(SERVO_ABOVE); Delay_ms(20); }

    Servo_SetAngle(SERVO_ABOVE, 270, 2000);  // 270度位置，2秒
    for(int i = 0; i < 100; i++) { Servo_UpdatePosition(SERVO_ABOVE); Delay_ms(20); }

    Servo_SetAngle(SERVO_ABOVE, 135, 2000);  // 回到中心，2秒
    for(int i = 0; i < 100; i++) { Servo_UpdatePosition(SERVO_ABOVE); Delay_ms(20); }

    // 第二阶段：测试下方舵机
    OLED_Clear();
    OLED_ShowString(1, 1, "Test Below Servo");
    
    Servo_SetAngle(SERVO_BELOW, 0, 2000);    // 0度位置，2秒
    for(int i = 0; i < 100; i++) { Servo_UpdatePosition(SERVO_BELOW); Delay_ms(20); }

    Servo_SetAngle(SERVO_BELOW, 135, 2000);  // 中心位置，2秒
    for(int i = 0; i < 100; i++) { Servo_UpdatePosition(SERVO_BELOW); Delay_ms(20); }

    Servo_SetAngle(SERVO_BELOW, 270, 2000);  // 270度位置，2秒
    for(int i = 0; i < 100; i++) { Servo_UpdatePosition(SERVO_BELOW); Delay_ms(20); }

    Servo_SetAngle(SERVO_BELOW, 135, 2000);  // 回到中心，2秒
    for(int i = 0; i < 100; i++) { Servo_UpdatePosition(SERVO_BELOW); Delay_ms(20); }

    // 测试完成，显示完成信息
    OLED_Clear();
    OLED_ShowString(1, 1, "Servo Test Done ");
    OLED_ShowString(2, 1, "Check Movement");
```

## 舵机部分代码

结构体数组的用法

**static**：

- **作用域限制**：只能在当前文件（Servo.c）内访问，其他文件无法直接访问
- **生命周期**：程序运行期间一直存在，不会被销毁
- **初始化**：自动初始化为0（所有成员都是0）

```
g_servos数组:
┌─────────────────────────────────────────────────────────┐
│  索引0 (SERVO_ABOVE)     │  索引1 (SERVO_BELOW)        │
├─────────────────────────┼─────────────────────────────┤
│ current_pwm: 1500.0     │ current_pwm: 1500.0         │
│ increment:   0.0        │ increment:   0.0             │
│ target_pwm:  1500       │ target_pwm:  1500            │
│ time_ms:     0          │ time_ms:     0               │
└─────────────────────────┴─────────────────────────────┘
```

### 舵机相关参数定义

```C
#define SERVO_NUM 2  // 定义有2个舵机

typedef struct
{
    float current_pwm;    // 当前PWM值(us)
    float increment;      // PWM增量(us/周期)
    uint16_t target_pwm;  // 目标PWM值(us)
    uint16_t time_ms;     // 移动时间(ms)
} Servo_t;

static Servo_t g_servos[SERVO_NUM];
```

### 初始化代码

中立位置是135°，pwm为1500

```C
void Servo_Init(void)
{
    PWM_Init();  // 初始化PWM (周期设置为20ms)
    
    // 初始位置1.5ms (1500us)，对应135度位置
    g_servos[SERVO_ABOVE].current_pwm = 1500;   
    g_servos[SERVO_BELOW].current_pwm = 1500;
    
    PWM_SetCompare1(1500); // 通道1
    PWM_SetCompare2(1500); // 通道2
}
```

### 舵机角度函数

```c
// 设置舵机角度函数 (0-270度)
void Servo_SetAngle(uint8_t servo_id, float angle, uint16_t duration_ms)
{
    // 角度限幅 (0-270度)
    if(angle < 0) angle = 0;
    else if(angle > SERVO_RANGE_DEG) angle = SERVO_RANGE_DEG;
    
    // 角度转PWM: PWM = 500 + (angle/270)*2000
    uint16_t target_pwm = (uint16_t)(500 + (angle / SERVO_RANGE_DEG) * 2000);
    
    // 调用PWM设置函数
    Servo_SetTarget(servo_id, target_pwm, duration_ms);
}
```

### 舵机目标函数

```c
void Servo_SetTarget(uint8_t servo_id, uint16_t target_pwm, uint16_t duration_ms)
{
    if(servo_id >= SERVO_NUM) return;

    // PWM值限制范围 (500-2500us)
    if(target_pwm < SERVO_MIN_PWM) target_pwm = SERVO_MIN_PWM;
    else if(target_pwm > SERVO_MAX_PWM) target_pwm = SERVO_MAX_PWM;

    g_servos[servo_id].target_pwm = target_pwm;
    
    if(duration_ms < 20) // 快速移动
    {
        g_servos[servo_id].current_pwm = (float)target_pwm;
        g_servos[servo_id].increment = 0;
        
        // 直接设置硬件PWM输出
        if(servo_id == SERVO_ABOVE) 
            PWM_SetCompare1(target_pwm);
        else 
            PWM_SetCompare2(target_pwm);
    }
    else // 平滑移动
    {
        g_servos[servo_id].time_ms = duration_ms;
        
        // 计算每20ms周期的增量 (主循环周期=20ms)
        g_servos[servo_id].increment = 
            (float)(target_pwm - g_servos[servo_id].current_pwm) / 
            (duration_ms / 20.0f);
    }
}
```



### 舵机平滑运动代码

```C
void Servo_UpdatePosition(uint8_t servo_id)
{
    // 1. 检查是否需要更新（增量太小就停止）
    if(servo_id >= SERVO_NUM || 
       fabsf(g_servos[servo_id].increment) < 0.1f) // 增量太小认为静止
        return;

    // 2. 计算当前位置与目标位置的差距
    float diff = g_servos[servo_id].target_pwm - g_servos[servo_id].current_pwm;
    
    // 3. 判断是否到达目标位置
    // 接近目标位置 (精度1us，对应0.054度)
    if(fabsf(diff) <= fabsf(g_servos[servo_id].increment))
    {
        // 到达目标位置，直接设置为目标值
        g_servos[servo_id].current_pwm = g_servos[servo_id].target_pwm;
        g_servos[servo_id].increment = 0;
    }
    else // 继续移动
    {
        // 未到达 - 继续向目标移动一小步
        g_servos[servo_id].current_pwm += g_servos[servo_id].increment;
    }
    
    // 更新PWM输出
    if(servo_id == SERVO_ABOVE) 
        PWM_SetCompare1((uint16_t)g_servos[servo_id].current_pwm);
    else 
        PWM_SetCompare2((uint16_t)g_servos[servo_id].current_pwm);
}
```

## PID部分（k230）

```
OpenMV摄像头视野 (QVGA 320×240)
┌─────────────────────────────────┐ ← Y=0 (图像顶部)
│  (0,0)             (320,0)     │
│                                 │
│        (160,120) ← 中心点       │ ← Y=120 (图像中心)
│          目标位置               │
│                                 │
│  (0,240)          (320,240)    │
└─────────────────────────────────┘ ← Y=240 (图像底部)
↑                               ↑
X=0                           X=320
(图像左边)                    (图像右边)
```

```
输出 = Kp×误差 + Ki×积分 + Kd×微分
     = Kp×e(t) + Ki×∫e(t)dt + Kd×[e(t)-e(t-1)]
```

**各项含义：**

1. **比例项 (P)**: `Kp × 误差`
   - 当前误差越大，输出越大
   - 快速响应，但可能产生稳态误差
2. **积分项 (I)**: `Ki × 积分`, 积分项就是误差累积
   - 累积历史误差，消除稳态误差
   - `积分 += 当前误差`
3. **微分项 (D)**: `Kd × (当前误差 - 上次误差)`
   - 预测误差变化趋势，提前调节
   - 减少超调，提高稳定性

在您的色块追踪系统中：

- **目标值 (tar_S)**：色块应该在的位置（如屏幕中心160, 120）
- **实际值 (true_S)**：色块当前的位置（从OpenMV获取的坐标）
- **误差**：`目标位置 - 实际位置`



时刻    目标    实际    误差    积分    微分    输出
 1         160     100     60        60        60     调整舵机向右
 2         160     120     40       100      -20     继续向右但减速
 3         160     140     20       120      -20     继续微调
 4         160     155      5        125      -15     接近目标
 5         160     160      0        125       -5       到达目标



X轴方向控制

```
色块在屏幕左边          色块在屏幕中心          色块在屏幕右边
xx < 160               xx = 160               xx > 160
│                      │                      │
│ 舵机向左转            │ 舵机不动              │ 舵机向右转
│ (减小PWM)            │ (保持1500)           │ (增加PWM)
▼                      ▼                      ▼
云台向左转动           云台保持中心           云台向右转动
```

Y轴方向控制

```
色块在屏幕上方          色块在屏幕中心          色块在屏幕下方
yy < 120               yy = 120               yy > 120
│                      │                      │
│ 舵机向上转            │ 舵机不动              │ 舵机向下转
│ (减小PWM)            │ (保持1500)           │ (增加PWM)
▼                      ▼                      ▼
云台向上转动           云台保持中心           云台向下转动
```

![image-20250717185923178](C:\Users\Anna\AppData\Roaming\Typora\typora-user-images\image-20250717185923178.png)



```c
#include "stm32f10x.h"                  // Device header
#include "PWM.h"
#include "OLED.h"
#include "Servo.h"      // 包含Servo.h以使用舵机相关函数
#include "math.h"       // 用于fabs函数

// 使用结构体来组合PID参数
typedef struct {
    float kp, ki, kd;// PID参数
    float integral;// 积分值
    float last_err;// 上一次误差
} PID_Controller;

// 根据实际舵机测试结果调整PID参数符号
// 上方舵机：PWM减小→向下，PWM增加→向上
// 下方舵机：PWM减小→向右，PWM增加→向左
// 减小PID参数，避免过度调节和积分饱和
PID_Controller pid_x = {0.35, 0.001, 0.02, 0, 0};   // X轴(水平)减小参数
PID_Controller pid_y = {0.35, 0.001, 0.02, 0, 0};   // Y轴(垂直)减小参数

#define SERVO_X SERVO_BELOW  // X轴(水平)控制 = 下方舵机 (左右转动)
#define SERVO_Y SERVO_ABOVE  // Y轴(垂直)控制 = 上方舵机 (上下转动)

int16_t Err_X = 0,Err_Y = 0;

int16_t x_pwm = 0,
        now_x;

int16_t y_pwm = 0,
        now_y,
        ks1 = 1500,
        ks2 = 1500;

void pid_S_Y(float true_S, float tar_S)
{
    // 计算当前误差
    float current_err = tar_S - true_S;
    
    // 死区控制：误差太小时不调节，避免抖动
    if(fabs(current_err) < 5) {
        current_err = 0;
        // 误差很小时清零积分，避免积分项继续累积
        pid_y.integral = 0;
    }
    
    // 积分项：累积误差（增加积分限幅）
    pid_y.integral += current_err;
    
    // 积分限幅，防止积分饱和
    if(pid_y.integral > 1000) pid_y.integral = 1000;
    else if(pid_y.integral < -1000) pid_y.integral = -1000;
    
    // 微分项：当前误差 - 上次误差
    float derivative = current_err - pid_y.last_err;
    
    // PID计算：比例 + 积分 + 微分
    y_pwm = pid_y.kp * current_err + pid_y.ki * pid_y.integral + pid_y.kd * derivative;
    
    // PID输出限幅（限制调节幅度）
    if(y_pwm > 300) y_pwm = 300;
    else if(y_pwm < -300) y_pwm = -300;
    
    // 更新上次误差（为下次计算做准备）
    pid_y.last_err = current_err;
    
    // 输出值 = 中心位置 + PID调节量
    now_y = ks1 + y_pwm;
    
    // PWM输出限幅（更安全的范围）
    if(now_y > 2200)
    {
        now_y = 2200;
    }
    else if(now_y < 800)
    {
        now_y = 800;
    }
    
    Servo_SetTarget(SERVO_Y, now_y, 0); // 统一使用Servo接口
    OLED_ShowSignedNum(4,8,now_y,5);
}

void pid_S_X(float true_S, float tar_S)
{
    // 计算当前误差
    float current_err = tar_S - true_S;
    
    // 死区控制：误差太小时不调节，避免抖动
    if(fabs(current_err) < 5) {
        current_err = 0;
        // 误差很小时清零积分，避免积分项继续累积
        pid_x.integral = 0;
    }
    
    // 积分项：累积误差（增加积分限幅）
    pid_x.integral += current_err;
    
    // 积分限幅，防止积分饱和
    if(pid_x.integral > 1000) pid_x.integral = 1000;
    else if(pid_x.integral < -1000) pid_x.integral = -1000;
    
    // 微分项：当前误差 - 上次误差
    float derivative = current_err - pid_x.last_err;
    
    // PID计算：比例 + 积分 + 微分
    x_pwm = pid_x.kp * current_err + pid_x.ki * pid_x.integral + pid_x.kd * derivative;
    
    // PID输出限幅（限制调节幅度）
    if(x_pwm > 300) x_pwm = 300;
    else if(x_pwm < -300) x_pwm = -300;
    
    // 更新上次误差（为下次计算做准备）
    pid_x.last_err = current_err;
    
    // 输出值 = 中心位置 + PID调节量
    now_x = ks2 + x_pwm;
    
    // PWM输出限幅（更安全的范围）
    if(now_x > 2200)
    {
        now_x = 2200;
    }
    else if(now_x < 800)
    {
        now_x = 800;
    }
    
    Servo_SetTarget(SERVO_X, now_x, 0);
    OLED_ShowSignedNum(3,8,now_x,5);
}


```



## 串口通信部分

```
完整数据帧结构:
┌────────┬──────────┬──────────┬──────────┬──────────┬────────┐
│ 帧头   │ X高字节  │ X低字节  │ Y高字节  │ Y低字节  │ 帧尾   │
│ 0x2C   │RxBuffer[0]│RxBuffer[1]│RxBuffer[2]│RxBuffer[3]│ 0x5B   │
└────────┴──────────┴──────────┴──────────┴──────────┴────────┘
```

- **坐标范围**：X轴 0-320，Y轴 0-240
- **单字节范围**：0-255 (8位)
- **问题**：X轴最大值320 > 255，单字节存不下！

```
320 (十进制) = 0x0140 (十六进制) = 0000000101000000 (二进制)
                    ↓
        高字节: 0x01 = 1        低字节: 0x40 = 64
        ┌─────────────┐         ┌─────────────┐
        │   第9-16位  │         │   第1-8位   │
        │ 00000001    │         │ 01000000    │
        └─────────────┘         └─────────────┘
```

```C
// 从接收缓冲区读取4个字节
uint16_t x_high = RxBuffer[0];  // X坐标高字节
uint16_t x_low = RxBuffer[1];   // X坐标低字节
uint16_t y_high = RxBuffer[2];  // Y坐标高字节
uint16_t y_low = RxBuffer[3];   // Y坐标低字节

// 组合X坐标
xx = (x_high << 8) | x_low;
// 组合Y坐标
yy = (y_high << 8) | y_low;
```

```
OpenMV发送数据:    STM32接收处理:
坐标(320, 240)
      ↓
   分解为字节
      ↓
0x2C 0x01 0x40 0x00 0xF0 0x5B
 ↓    ↓    ↓    ↓    ↓    ↓
帧头  X高  X低  Y高  Y低  帧尾
      ↓
   串口传输
      ↓
  USART1中断接收
      ↓
  存入RxBuffer[]
      ↓
Process_Received_Data()
      ↓
   重新组合
      ↓
xx = (0x01 << 8) | 0x40 = 320
yy = (0x00 << 8) | 0xF0 = 240
```

```c
#include "stm32f10x.h"
#include <string.h>
#include "chuanko.h"
#include "Servo.h"      // 舵机控制头文件

// 接收数据相关变量
uint16_t xx,yy;// 外部变量，接收的X和Y坐标
char RxBuffer[RX_BUFFER_SIZE];  // 接收数据的缓冲区
volatile uint8_t RxIndex = 0;   // 接收数据的索引

// 接收状态机
typedef enum {
    STATE_WAIT_HEADER,          // 等待帧头
    STATE_RECEIVE_DATA,         // 正在接收数据阶段
    STATE_WAIT_TAIL     		// 等待帧尾
} ReceiveState;

volatile ReceiveState state = STATE_WAIT_HEADER; // 当前接收状态
uint8_t data_received = 0;		// 接收到一帧数据标志位

// USART1初始化
void USART1_Init(void) {
    USART_InitTypeDef USART_InitStructure;
    GPIO_InitTypeDef GPIO_InitStructure;

    // 使能USART1与GPIO时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA, ENABLE);

    // 配置USART1的TX (PA9) 和 RX (PA10) 引脚
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;           // TX
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;     // 复用推挽输出
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;          // RX
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; // 浮空输入
    GPIO_Init(GPIOA, &GPIO_InitStructure);

    // 初始化USART1
    USART_InitStructure.USART_BaudRate = 115200;          // 波特率115200
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;  // 数据位8位
    USART_InitStructure.USART_StopBits = USART_StopBits_1; // 停止位1位
    USART_InitStructure.USART_Parity = USART_Parity_No;  // 无校验位
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;  // 无硬件流控制
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;  // 收发模式
    USART_Init(USART1, &USART_InitStructure);

    // 使能USART1
    USART_Cmd(USART1, ENABLE);

    // 配置USART1中断优先级
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; // 抢占优先级0（最高）
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;        // 子优先级0
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);

    // 使能USART1接收中断
    USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
}

// USART1中断处理函数
void USART1_IRQHandler(void) {
    if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) {
        uint8_t received = USART_ReceiveData(USART1);  // 接收数据

        switch (state) {
            case STATE_WAIT_HEADER:      // 等待帧头
                if (received == 0x2C) {  // 匹配帧头
                    state = STATE_RECEIVE_DATA; // 状态为开始接收数据
                    RxIndex = 0;
                }
                break;

            case STATE_RECEIVE_DATA:     // 正在接收数据阶段
                if (received == 0x5B) {  // 匹配帧尾
                    state = STATE_WAIT_TAIL; // 状态为等待帧尾
                    data_received = 1;   // 设置接收到数据标志位为1
                } else {
                    if (RxIndex < RX_BUFFER_SIZE - 1) {
                        RxBuffer[RxIndex++] = received;  // 存储接收到的数据
                    }
                }
                break;

            case STATE_WAIT_TAIL:			   // 等待帧尾状态
                state = STATE_WAIT_HEADER; // 状态为等待帧头    
                break;
        }
    }
}

// 处理接收到的数据
void Process_Received_Data(void) {
    NVIC_DisableIRQ(USART1_IRQn); // 禁止中断，防止处理时被干扰
    if (data_received) {
        // 数据有效性检查
        if (RxIndex >= 4) {  // 确认接收到4个字节的数据，x高字节、x低字节、y高字节、y低字节
            // 组合x值
            uint16_t x_high = RxBuffer[0];
            uint16_t x_low = RxBuffer[1];
            xx = (x_high << 8) | x_low;//组合高8位和低8位
            if(xx>600) xx = 600; // 限制X坐标最大值为600
            // 组合y值
            uint16_t y_high = RxBuffer[2];
            uint16_t y_low = RxBuffer[3];
            yy = (y_high << 8) | y_low;
            if(yy>400) yy = 400; // 限制Y坐标最大值为400
            // 判断是否收到(0, 0)
            if (xx == 0 && yy == 0) {
                // 设置舵机目标位置为1500us，500ms内到达
                Servo_SetTarget(SERVO_ABOVE, 1500, 500); // 500ms内到达
                Servo_SetTarget(SERVO_BELOW, 1500, 500);
            }
        }
        // 重置接收状态
        data_received = 0;
        RxIndex = 0;
        state = STATE_WAIT_HEADER;
    }
    NVIC_EnableIRQ(USART1_IRQn); // 使能中断
}

```

```C
#ifndef __CHUANKO_H
#define __CHUANKO_H

// 外部变量xx和yy
extern uint16_t xx, yy;

// 接收缓冲区大小
#define RX_BUFFER_SIZE 100

// 函数声明
void USART1_Init(void);
void Process_Received_Data(void);

#endif

```



## 按键测试代码

```C
// OLED显示初始化
    OLED_Clear();
    OLED_ShowString(1, 1, "Key:");     // 显示按键标签
    OLED_ShowString(2, 1, "Status: OK");
    OLED_ShowString(3, 1, "Test Mode");
    
    uint8_t test_counter = 0;
    //OLED_ShowString(4, 1, "now_y:");//当前Y坐标

    while (1)
    {
        uint8_t key = Key_Scan();
        
        // 显示按键值
        OLED_ShowNum(1, 6, key, 1);
        
        // 显示测试计数器证明程序在运行
        OLED_ShowNum(4, 1, test_counter, 3);
        test_counter++;
        if (test_counter > 999) test_counter = 0;
        
        // 按键响应测试 - 持续显示按键状态
        if (key == 1) {
            OLED_ShowString(2, 1, "Key1 Press  ");
            OLED_ShowString(3, 1, "PB3 = LOW   ");
        } else if (key == 2) {
            OLED_ShowString(2, 1, "Key2 Press  ");
            OLED_ShowString(3, 1, "PB4 = LOW   ");
        } else if (key == 3) {
            OLED_ShowString(2, 1, "Key3 Press  ");
            OLED_ShowString(3, 1, "PA12 = LOW  ");
        } else if (key == 4) {
            OLED_ShowString(2, 1, "Key4 Press  ");
            OLED_ShowString(3, 1, "PA15 = LOW  ");
        } else {
            OLED_ShowString(2, 1, "No Key      ");
            OLED_ShowString(3, 1, "All HIGH    ");
        }
        
        Delay_ms(50);  // 50ms更新一次，更流畅
    }
```



Key库代码

```C
#include "stm32f10x.h"                  // Device header
#include "Delay.h"

#define KEY_NUM     4       // 按键数量
#define KEY_DELAY   3       // 多少次扫描稳定才算有效（3×10ms = 30ms消抖）

// 按键读取宏（默认高电平，按下为低）
#define READ_KEY1    (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_3) == 0)
#define READ_KEY2    (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_4) == 0)
#define READ_KEY3    (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_12) == 0)
#define READ_KEY4    (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_15) == 0)

// 内部按键状态变量
static uint8_t key_state[KEY_NUM] = {0};
static uint8_t key_count[KEY_NUM] = {0};
static uint8_t key_flag[KEY_NUM] = {0}; // 标记是否有新按键按下

void Key_Init(void)
{
    // 先使能时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
    
    // 禁用JTAG，释放PB3、PB4引脚
    GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);
    
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;  // 上拉输入
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    
    // 配置PB3, PB4
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4;
    GPIO_Init(GPIOB, &GPIO_InitStructure);

    // 配置PA12,PB15
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_15;
    GPIO_Init(GPIOA, &GPIO_InitStructure);
}


// 定时器中断调用，建议10ms周期
void Key_TimerScan(void)
{
    uint8_t i;
    uint8_t key_input[KEY_NUM] = {
        READ_KEY1,
        READ_KEY2,
        READ_KEY3,
        READ_KEY4
    };

    for (i = 0; i < KEY_NUM; i++)
    {
        if (key_input[i]) // 按键被按下（低电平）
        {
            if (key_count[i] < KEY_DELAY)
                key_count[i]++;
            else if (key_state[i] == 0) // 第一次检测到稳定按下
            {
                key_state[i] = 1;
                key_flag[i] = 1; // 标记已按下
            }
        }
        else // 松开状态
        {
            key_count[i] = 0;
            key_state[i] = 0;
            key_flag[i] = 0;  // 松开时才清除标志
        }
    }
}

// 在主循环中调用此函数获取按键值（保持状态）
uint8_t Key_Scan(void)
{
    for (uint8_t i = 0; i < KEY_NUM; i++)
    {
        if (key_flag[i])
        {
            return i + 1; // 键值从1开始，不清除标志
        }
    }
    return 0; // 无按键按下
}

// 清除按键标志的函数（可选调用）
void Key_ClearFlag(void)
{
    for (uint8_t i = 0; i < KEY_NUM; i++)
    {
        key_flag[i] = 0;
    }
}

```

## 定时器调用

```C
#include "stm32f10x.h"
#include "KEY.h"  // 添加按键头文件

void TIM3_Init(void)
{
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);  // 开启定时器3时钟

    TIM_InternalClockConfig(TIM3); // 使用内部时钟

    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
    TIM_TimeBaseStructure.TIM_Prescaler = 7199;     // 72MHz / (7199+1) = 10kHz
    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseStructure.TIM_Period = 99;          // 10kHz / (99+1) = 100Hz = 10ms
    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);

    TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);      // 允许更新中断
    TIM_Cmd(TIM3, ENABLE);                          // 使能定时器

    // 中断优先级配置
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2; // 抢占优先级2（低于USART1）
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;        // 子优先级0
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
}

// TIM3中断处理函数
void TIM3_IRQHandler(void)
{
    if (TIM_GetITStatus(TIM3, TIM_IT_Update) == SET)
    {
        Key_TimerScan();  // 每10ms扫描一次按键
        TIM_ClearITPendingBit(TIM3, TIM_IT_Update);  // 清除中断标志位
    }
}


/*
void TIM3_IRQHandler(void)
{
	if (TIM_GetITStatus(TIM3, TIM_IT_Update) == SET)
	{
		
		TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
	}
}
*/

```

## 激光驱动部分

用蜂鸣器模块做继电器部分



```C
#include "stm32f10x.h"

void Light_Init(void)
{
    
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB , ENABLE);
    
    GPIO_InitTypeDef GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;  
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    
    
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
	GPIO_SetBits(GPIOB,GPIO_Pin_5);

}
 
void Light_ON(void)
{
	GPIO_ResetBits(GPIOB,GPIO_Pin_5);
}

void Light_OFF(void)
{
	GPIO_SetBits(GPIOB,GPIO_Pin_5);
}

```

E题代码

pid部分

```c
#include "stm32f10x.h"                  // Device header
#include "PWM.h"
#include "OLED.h"
#include "Servo.h"      // 包含Servo.h以使用舵机相关函数
#include "math.h"       // 用于fabs函数

// 使用结构体来组合PID参数
typedef struct {
    float kp, ki, kd;// PID参数
    float integral;// 积分值
    float last_err;// 上一次误差
} PID_Controller;

// 根据实际舵机测试结果调整PID参数符号
// 上方舵机：PWM减小→向上，PWM增加→向下
// 下方舵机：PWM减小→向左，PWM增加→向右
// 专门针对X轴优化，进一步增大转动角度
PID_Controller pid_x = {0.8, 0.002, 0.08, 0, 0};   // X轴专用优化：Kp进一步增大到0.8
PID_Controller pid_y = {0.35, 0.001, 0.02, 0, 0};   // Y轴保持不变

#define SERVO_X SERVO_BELOW  // X轴(水平)控制 = 下方舵机 (左右转动)
#define SERVO_Y SERVO_ABOVE  // Y轴(垂直)控制 = 上方舵机 (上下转动)

int16_t Err_X = 0,Err_Y = 0;

int16_t x_pwm = 0,
        now_x;

int16_t y_pwm = 0,
        now_y,
        ks1 = 1500,
        ks2 = 1500;

void pid_S_Y(float true_S, float tar_S)
{
    // 计算当前误差
    float current_err = tar_S - true_S;
    
    // 死区控制：误差太小时不调节，避免抖动
    if(fabs(current_err) < 5) {
        current_err = 0;
        // 误差很小时清零积分，避免积分项继续累积
        pid_y.integral = 0;
    }
    
    // 积分项：累积误差（增加积分限幅）
    pid_y.integral += current_err;
    
    // 积分限幅，防止积分饱和
    if(pid_y.integral > 1000) pid_y.integral = 1000;
    else if(pid_y.integral < -1000) pid_y.integral = -1000;
    
    // 微分项：当前误差 - 上次误差
    float derivative = current_err - pid_y.last_err;
    
    // PID计算：比例 + 积分 + 微分
    y_pwm = pid_y.kp * current_err + pid_y.ki * pid_y.integral + pid_y.kd * derivative;
    
    // PID输出限幅（限制调节幅度）
    if(y_pwm > 300) y_pwm = 300;
    else if(y_pwm < -300) y_pwm = -300;
    
    // 更新上次误差（为下次计算做准备）
    pid_y.last_err = current_err;
    
    // 输出值 = 中心位置 + PID调节量
    now_y = ks1 + y_pwm;
    
    // PWM输出限幅（更安全的范围）
    if(now_y > 2200)
    {
        now_y = 2200;
    }
    else if(now_y < 800)
    {
        now_y = 800;
    }
    
    Servo_SetTarget(SERVO_Y, now_y, 50); // 使用50ms响应时间，平衡速度和稳定性
    OLED_ShowSignedNum(4,8,now_y,5);
}

void pid_S_X(float true_S, float tar_S)
{
    // 计算当前误差
    float current_err = tar_S - true_S;
    
    // 死区控制：进一步减小死区，提高敏感度
    if(fabs(current_err) < 2) {
        current_err = 0;
        // 误差很小时清零积分，避免积分项继续累积
        pid_x.integral = 0;
    }
    
    // 积分项：累积误差（增加积分限幅）
    pid_x.integral += current_err;
    
    // 积分限幅，防止积分饱和
    if(pid_x.integral > 600) pid_x.integral = 600;
    else if(pid_x.integral < -600) pid_x.integral = -600;
    
    // 微分项：当前误差 - 上次误差
    float derivative = current_err - pid_x.last_err;
    
    // PID计算：比例 + 积分 + 微分
    x_pwm = pid_x.kp * current_err + pid_x.ki * pid_x.integral + pid_x.kd * derivative;
    
    // PID输出限幅（X轴专用：进一步扩大调节幅度以获得最大转动角度）
    if(x_pwm > 1000) x_pwm = 1000;
    else if(x_pwm < -1000) x_pwm = -1000;
    
    // 更新上次误差（为下次计算做准备）
    pid_x.last_err = current_err;
    
    // 输出值 = 中心位置 + PID调节量
    now_x = ks2 + x_pwm;
    
    // PWM输出限幅（更安全的范围）
    if(now_x > 2200)
    {
        now_x = 2200;
    }
    else if(now_x < 800)
    {
        now_x = 800;
    }

    Servo_SetTarget(SERVO_X, now_x, 20); // X轴专用：使用5ms超快响应时间
    OLED_ShowSignedNum(3,8,now_x,5);
}


```



```
void pid3_S_X(float true_S, float tar_S)
{
    // 任务3：分阶段X轴控制
    // 阶段0：粗调搜索矩形 - 大角度快速调整
    // 阶段1：精调瞄准靶心 - 小角度精确控制
    
    float current_err = tar_S - true_S;
    static uint32_t frame_count = 0;
    frame_count++;
    
    // 检测是否找到目标（误差较小且稳定）
    if(fabs(current_err) < 15 && task3_stage == 0) {
        stable_count++;
        if(stable_count > 10) {  // 连续10帧稳定
            task3_stage = 1;  // 切换到精调阶段
            last_stable_x = true_S;  // 记录当前稳定位置
            target_found_time = frame_count;
            stable_count = 0;
            // 清零积分项，重新开始
            pid3_x.integral = 0;
        }
    } else if(fabs(current_err) > 30) {
        // 误差过大，重新进入搜索阶段
        stable_count = 0;
        if(task3_stage == 1) {
            task3_stage = 0;  // 回到搜索阶段
            pid3_x.integral = 0;
        }
    }
    
    if(task3_stage == 0) {
        // ========== 阶段0：粗调搜索阶段 ==========
        // 大角度快速搜索，使用激进参数
        
        // 搜索阶段死区
        if(fabs(current_err) < 5) {
            current_err = 0;
            pid3_x.integral = 0;
        }
        
        // 搜索阶段积分
        pid3_x.integral += current_err;
        if(pid3_x.integral > 1000) pid3_x.integral = 1000;
        else if(pid3_x.integral < -1000) pid3_x.integral = -1000;
        
        // 搜索阶段微分
        float derivative = current_err - pid3_x.last_err;
        
        // 搜索阶段PID计算（激进参数）
        float search_kp = 2.0;  // 大比例系数，快速响应
        float search_ki = 0.005;
        float search_kd = 0.1;
        
        x_pwm = search_kp * current_err + search_ki * pid3_x.integral + search_kd * derivative;
        
        // 搜索阶段大输出限幅
        if(x_pwm > 1200) x_pwm = 1200;
        else if(x_pwm < -1200) x_pwm = -1200;
        
        // 快速响应时间
        uint16_t response_time = 15;
        
        // 输出值计算
        now_x = ks2 + x_pwm;
        
        // PWM限幅
        if(now_x > 2200) now_x = 2200;
        else if(now_x < 800) now_x = 800;
        
        Servo_SetTarget(SERVO_X, now_x, response_time);
        
        // 显示搜索状态
        OLED_ShowSignedNum(3,8,now_x,5);
        
    } else {
        // ========== 阶段1：精调瞄准阶段 ==========
        // 小角度精确控制，使用保守参数
        
        // 精调阶段死区（更小）
        if(fabs(current_err) < 2) {
            current_err = 0;
            pid3_x.integral = 0;
        }
        
        // 精调阶段积分（更保守）
        pid3_x.integral += current_err;
        if(pid3_x.integral > 400) pid3_x.integral = 400;
        else if(pid3_x.integral < -400) pid3_x.integral = -400;
        
        // 精调阶段微分
        float derivative = current_err - pid3_x.last_err;
        
        // 精调阶段PID计算（保守参数）
        float fine_kp = 0.6;   // 小比例系数，精确控制
        float fine_ki = 0.001;
        float fine_kd = 0.05;
        
        x_pwm = fine_kp * current_err + fine_ki * pid3_x.integral + fine_kd * derivative;
        
        // 精调阶段小输出限幅
        if(x_pwm > 300) x_pwm = 300;
        else if(x_pwm < -300) x_pwm = -300;
        
        // 慢响应时间，更稳定
        uint16_t response_time = 40;
        
        // 输出值计算
        now_x = ks2 + x_pwm;
        
        // PWM限幅
        if(now_x > 2200) now_x = 2200;
        else if(now_x < 800) now_x = 800;
        
        Servo_SetTarget(SERVO_X, now_x, response_time);
        
        // 显示精调状态
        OLED_ShowSignedNum(3,8,now_x,5);
    }
    
    // 更新上次误差
    pid3_x.last_err = current_err;
}
```



```c
void pid3_S_X(float true_S, float tar_S)
{
    // 任务3：分阶段X轴控制
    // 阶段0：粗调搜索矩形 - 大角度快速调整
    // 阶段1：精调瞄准靶心 - 小角度精确控制
    
    float current_err = tar_S - true_S;
    static uint32_t frame_count = 0;
    frame_count++;
    
    // ========== 目标丢失检测 ==========
    // 检测是否丢失目标（X坐标为0或超出合理范围）
    uint8_t target_lost = (true_S < 10 || true_S > 310 || fabs(current_err) > 150);
    
    if(target_lost) {
        target_lost_count++;
        
        // 连续丢失目标5帧以上，启动扫描搜索
        if(target_lost_count > 5) {
            // ========== 主动扫描搜索模式 ==========
            scan_step_count++;
            
            // 计算扫描目标位置（正弦波扫描）
            float scan_progress = (scan_step_count % 120) / 60.0f; // 每60步一个半周期
            float scan_target;
            
            if(scan_progress <= 1.0f) {
                // 正弦波扫描：从中心-幅度 到 中心+幅度
                scan_target = scan_center + scan_amplitude * (2 * scan_progress - 1);
            } else {
                // 反向扫描
                scan_target = scan_center - scan_amplitude * (2 * (scan_progress - 1) - 1);
            }
            
            // 使用扫描目标位置进行PID控制
            current_err = scan_target - 160; // 相对于屏幕中心的误差
            
            // 搜索模式的PID参数（增大Kp获得更大转角）
            pid_search_x.integral += current_err * 0.8; // 提高积分增长率
            if(pid_search_x.integral > 1000) pid_search_x.integral = 1000;
            else if(pid_search_x.integral < -1000) pid_search_x.integral = -1000;
            
            float derivative = current_err - pid_search_x.last_err;
            x_pwm = 2.5 * current_err + 0.003 * pid_search_x.integral + 0.15 * derivative;
            
            // 扫描时使用大输出幅度，确保足够转角
            if(x_pwm > 800) x_pwm = 800;
            else if(x_pwm < -800) x_pwm = -800;
            
            // 输出值计算
            now_x = ks2 + x_pwm;
            if(now_x > 2400) now_x = 2400;  // 扩大PWM范围
            else if(now_x < 600) now_x = 600;
            
            Servo_SetTarget(SERVO_X, now_x, 20); // 扫描时使用中等响应速度
            OLED_ShowSignedNum(3,8,now_x,5);
            
            pid_search_x.last_err = current_err;
            return; // 扫描模式下直接返回
        }
    } else {
        // 目标重新出现，重置丢失计数器
        target_lost_count = 0;
        scan_step_count = 0;
    }
    
    // ========== 正常目标跟踪模式 ==========
    // 检测是否找到目标（误差较小且稳定）
    if(fabs(current_err) < 15 && task3_stage == 0) {
        stable_count++;
        if(stable_count > 10) {  // 连续10帧稳定
            task3_stage = 1;  // 切换到精调阶段
            last_stable_x = true_S;  // 记录当前稳定位置
            target_found_time = frame_count;
            stable_count = 0;
            // 清零积分项，重新开始
            pid_finetune_x.integral = 0;
        }
    } else if(fabs(current_err) > 30) {
        // 误差过大，重新进入搜索阶段
        stable_count = 0;
        if(task3_stage == 1) {
            task3_stage = 0;  // 回到搜索阶段
            pid_finetune_x.integral = 0;
        }
    }
    
    if(task3_stage == 0) {
        // ========== 阶段0：粗调搜索阶段 ==========
        // 大角度快速搜索，使用激进参数
        
        // 搜索阶段死区（适当增大，避免小误差时不动作）
        if(fabs(current_err) < 3) {
            current_err = 0;
            pid_search_x.integral = 0;
        }
        
        // 搜索阶段积分
        pid_search_x.integral += current_err;
        if(pid_search_x.integral > 1000) pid_search_x.integral = 1000;
        else if(pid_search_x.integral < -1000) pid_search_x.integral = -1000;
        
        // 搜索阶段微分
        float derivative = current_err - pid_search_x.last_err;
        
        x_pwm = pid_search_x.kp * current_err + pid_search_x.ki * pid_search_x.integral + pid_search_x.kd * derivative;

        // 搜索阶段大输出限幅
        if(x_pwm > 1000) x_pwm = 1000;
        else if(x_pwm < -1000) x_pwm = -1000;

        // 更新上次误差（重要！）
        pid_search_x.last_err = current_err;

        // 快速响应时间
        uint16_t response_time = 100;  // 改为200ms，提高响应速度

        // 输出值计算
        now_x = ks2 + x_pwm;
        
        // PWM限幅
        if(now_x > 2500) now_x = 2500;
        else if(now_x < 800) now_x = 800;
        
        Servo_SetTarget(SERVO_X, now_x, response_time);
        
        // 显示搜索状态
        OLED_ShowSignedNum(3,8,now_x,5);
        
    } else {
        // ========== 阶段1：精调瞄准阶段 ==========
        // 小角度精确控制，使用保守参数
        
        // 精调阶段死区（更小）
        if(fabs(current_err) < 5) {
            current_err = 0;
            pid_finetune_x.integral = 0;
        }
        
        // 精调阶段积分（更保守）
        pid_finetune_x.integral += current_err;
        if(pid_finetune_x.integral > 400) pid_finetune_x.integral = 400;
        else if(pid_finetune_x.integral < -400) pid_finetune_x.integral = -400;

        // 精调阶段微分
        float derivative = current_err - pid_finetune_x.last_err;

        x_pwm = pid_finetune_x.kp * current_err + pid_finetune_x.ki * pid_finetune_x.integral + pid_finetune_x.kd * derivative;

        // 精调阶段小输出限幅
        if(x_pwm > 300) x_pwm = 300;
        else if(x_pwm < -300) x_pwm = -300;
        
        // 慢响应时间，更稳定
        uint16_t response_time = 20;
        
        // 输出值计算
        now_x = ks2 + x_pwm;
        
        // PWM限幅
        if(now_x > 2200) now_x = 2200;
        else if(now_x < 800) now_x = 800;
        
        Servo_SetTarget(SERVO_X, now_x, response_time);
        
        // 显示精调状态
        OLED_ShowSignedNum(3,8,now_x,5);
    }
    
    // 更新上次误差
    pid_finetune_x.last_err = current_err;
}
```

```
#include "stm32f10x.h"                  // Device header
#include "PWM.h"
#include "OLED.h"
#include "Servo.h"      // 包含Servo.h以使用舵机相关函数
#include "math.h"       // 用于fabs函数

// 使用结构体来组合PID参数
typedef struct {
    float kp, ki, kd;// PID参数
    float integral;// 积分值
    float last_err;// 上一次误差
} PID_Controller;

// 根据实际舵机测试结果调整PID参数符号
// 上方舵机：PWM减小→向上，PWM增加→向下
// 下方舵机：PWM减小→向左，PWM增加→向右
// 针对小车快速移动优化X轴：大幅提升响应速度和角度
PID_Controller pid_x = {0.8, 0.002, 0.08, 0, 0};   // X轴激进优化：超大Kp+强微分
PID_Controller pid_y = {0.35, 0.001, 0.02, 0, 0};   // Y轴保持不变
PID_Controller pid_search_x = {3.3, 0.005, 0.4, 0, 0};   // X轴激进优化：超大Kp+强微分
PID_Controller pid_finetune_x={0.6, 0.001, 0.05, 0, 0};   // X轴激进优化：超大Kp+强微分

// 任务3专用变量
static uint8_t task3_stage = 0;        // 0=搜索阶段, 1=精调阶段
static uint32_t stable_count = 0;      // 稳定计数器
static float last_stable_x = 0;        // 上次稳定的X位置
static uint32_t target_found_time = 0; // 目标找到的时间

// 目标丢失时的扫描搜索变量
static uint32_t target_lost_count = 0; // 目标丢失计数器
static uint8_t scan_direction = 1;     // 扫描方向：1=向右，0=向左
static float scan_center = 160;        // 扫描中心位置
static float scan_amplitude = 100;     // 扫描幅度（左右各100像素）
static uint32_t scan_step_count = 0;   // 扫描步数计数

#define SERVO_X SERVO_BELOW  // X轴(水平)控制 = 下方舵机 (左右转动)
#define SERVO_Y SERVO_ABOVE  // Y轴(垂直)控制 = 上方舵机 (上下转动)

int16_t Err_X = 0,Err_Y = 0;

int16_t x_pwm = 0,
        now_x;

int16_t y_pwm = 0,
        now_y,
        ks1 = 1500,
        ks2 = 1500;

// 添加运动预测变量
static float last_target_x = 160;  // 上次目标X位置
static float target_velocity_x = 0; // X方向运动速度

void pid_S_Y(float true_S, float tar_S)
{
    // 计算当前误差
    float current_err = tar_S - true_S;
    
    // 死区控制：误差太小时不调节，避免抖动
    if(fabs(current_err) < 5) {
        current_err = 0;
        // 误差很小时清零积分，避免积分项继续累积
        pid_y.integral = 0;
    }
    
    // 积分项：累积误差（增加积分限幅）
    pid_y.integral += current_err;
    
    // 积分限幅，防止积分饱和
    if(pid_y.integral > 1000) pid_y.integral = 1000;
    else if(pid_y.integral < -1000) pid_y.integral = -1000;
    
    // 微分项：当前误差 - 上次误差
    float derivative = current_err - pid_y.last_err;
    
    // PID计算：比例 + 积分 + 微分
    y_pwm = pid_y.kp * current_err + pid_y.ki * pid_y.integral + pid_y.kd * derivative;
    
    // PID输出限幅（限制调节幅度）
    if(y_pwm > 300) y_pwm = 300;
    else if(y_pwm < -300) y_pwm = -300;
    
    // 更新上次误差（为下次计算做准备）
    pid_y.last_err = current_err;
    
    // 输出值 = 中心位置 + PID调节量
    now_y = ks1 + y_pwm;
    
    // PWM输出限幅（更安全的范围）
    if(now_y > 2200)
    {
        now_y = 2200;
    }
    else if(now_y < 800)
    {
        now_y = 800;
    }
    
    Servo_SetTarget(SERVO_Y, now_y, 50); // 使用50ms响应时间，平衡速度和稳定性
    OLED_ShowSignedNum(4,8,now_y,5);
}


void pid_S_X(float true_S, float tar_S)
{
    // 计算当前误差
    float current_err = tar_S - true_S;
    
    // 死区控制：进一步减小死区，提高敏感度
    if(fabs(current_err) < 2) {
        current_err = 0;
        // 误差很小时清零积分，避免积分项继续累积
        pid_x.integral = 0;
    }
    
    // 积分项：累积误差（增加积分限幅）
    pid_x.integral += current_err;
    
    // 积分限幅，防止积分饱和
    if(pid_x.integral > 600) pid_x.integral = 600;
    else if(pid_x.integral < -600) pid_x.integral = -600;
    
    // 微分项：当前误差 - 上次误差
    float derivative = current_err - pid_x.last_err;
    
    // PID计算：比例 + 积分 + 微分
    x_pwm = pid_x.kp * current_err + pid_x.ki * pid_x.integral + pid_x.kd * derivative;
    
    // PID输出限幅（X轴专用：进一步扩大调节幅度以获得最大转动角度）
    if(x_pwm > 1000) x_pwm = 1000;
    else if(x_pwm < -1000) x_pwm = -1000;
    
    // 更新上次误差（为下次计算做准备）
    pid_x.last_err = current_err;
    
    // 输出值 = 中心位置 + PID调节量
    now_x = ks2 + x_pwm;
    
    // PWM输出限幅（更安全的范围）
    if(now_x > 2200)
    {
        now_x = 2200;
    }
    else if(now_x < 800)
    {
        now_x = 800;
    }

    Servo_SetTarget(SERVO_X, now_x, 20); // X轴专用：使用5ms超快响应时间
    OLED_ShowSignedNum(3,8,now_x,5);
}

void pid3_S_X(float true_S, float tar_S)
{
    // 任务3：分阶段X轴控制
    // 阶段0：粗调搜索矩形 - 大角度快速调整
    // 阶段1：精调瞄准靶心 - 小角度精确控制
    
    float current_err = tar_S - true_S;
    static uint32_t frame_count = 0;
    frame_count++;
    
    // ========== 目标丢失检测 ==========
    // 检测是否丢失目标（X坐标为0或超出合理范围）
    uint8_t target_lost = (true_S < 10 || true_S > 310 || fabs(current_err) > 150);
    
    if(target_lost) {
        target_lost_count++;
        
        // 连续丢失目标5帧以上，启动扫描搜索
        if(target_lost_count > 5) {
            // ========== 主动扫描搜索模式 ==========
            scan_step_count++;
            
            // 计算扫描目标位置（正弦波扫描）
            float scan_progress = (scan_step_count % 120) / 60.0f; // 每60步一个半周期
            float scan_target;
            
            if(scan_progress <= 1.0f) {
                // 正弦波扫描：从中心-幅度 到 中心+幅度
                scan_target = scan_center + scan_amplitude * (2 * scan_progress - 1);
            } else {
                // 反向扫描
                scan_target = scan_center - scan_amplitude * (2 * (scan_progress - 1) - 1);
            }
            
            // 使用扫描目标位置进行PID控制
            current_err = scan_target - 160; // 相对于屏幕中心的误差
            
            // 搜索模式的PID参数（增大Kp获得更大转角）
            pid_search_x.integral += current_err * 0.8; // 提高积分增长率
            if(pid_search_x.integral > 1000) pid_search_x.integral = 1000;
            else if(pid_search_x.integral < -1000) pid_search_x.integral = -1000;
            
            float derivative = current_err - pid_search_x.last_err;
            x_pwm = 2.5 * current_err + 0.003 * pid_search_x.integral + 0.15 * derivative;
            
            // 扫描时使用大输出幅度，确保足够转角
            if(x_pwm > 800) x_pwm = 800;
            else if(x_pwm < -800) x_pwm = -800;
            
            // 输出值计算
            now_x = ks2 + x_pwm;
            if(now_x > 2400) now_x = 2400;  // 扩大PWM范围
            else if(now_x < 600) now_x = 600;
            
            Servo_SetTarget(SERVO_X, now_x, 20); // 扫描时使用中等响应速度
            OLED_ShowSignedNum(3,8,now_x,5);
            
            pid_search_x.last_err = current_err;
            return; // 扫描模式下直接返回
        }
    } else {
        // 目标重新出现，重置丢失计数器
        target_lost_count = 0;
        scan_step_count = 0;
    }
    
    // ========== 正常目标跟踪模式 ==========
    // 检测是否找到目标（误差较小且稳定）
    if(fabs(current_err) < 15 && task3_stage == 0) {
        stable_count++;
        if(stable_count > 10) {  // 连续10帧稳定
            task3_stage = 1;  // 切换到精调阶段
            last_stable_x = true_S;  // 记录当前稳定位置
            target_found_time = frame_count;
            stable_count = 0;
            // 清零积分项，重新开始
            pid_finetune_x.integral = 0;
        }
    } else if(fabs(current_err) > 30) {
        // 误差过大，重新进入搜索阶段
        stable_count = 0;
        if(task3_stage == 1) {
            task3_stage = 0;  // 回到搜索阶段
            pid_finetune_x.integral = 0;
        }
    }
    
    if(task3_stage == 0) {
        // ========== 阶段0：粗调搜索阶段 ==========
        // 大角度快速搜索，使用激进参数
        
        // 搜索阶段死区
        if(fabs(current_err) < 5) {
            current_err = 0;
            pid_search_x.integral = 0;
        }
        
        // 搜索阶段积分
        pid_search_x.integral += current_err;
        if(pid_search_x.integral > 1000) pid_search_x.integral = 1000;
        else if(pid_search_x.integral < -1000) pid_search_x.integral = -1000;
        
        // 搜索阶段微分
        float derivative = current_err - pid_search_x.last_err;
        


        x_pwm = pid_search_x.kp * current_err + pid_search_x.ki * pid_search_x.integral + pid_search_x.kd * derivative;

        // 搜索阶段大输出限幅
        if(x_pwm > 1000) x_pwm = 1000;
        else if(x_pwm < -1000) x_pwm = -1000;

        // 快速响应时间
        uint16_t response_time = 500;
        
        // 输出值计算
        now_x = ks2 + x_pwm;
        
        // PWM限幅
        if(now_x > 2500) now_x = 2500;
        else if(now_x < 800) now_x = 800;
        
        Servo_SetTarget(SERVO_X, now_x, response_time);
        
        // 显示搜索状态
        OLED_ShowSignedNum(3,8,now_x,5);
        
    } else {
        // ========== 阶段1：精调瞄准阶段 ==========
        // 小角度精确控制，使用保守参数
        
        // 精调阶段死区（更小）
        if(fabs(current_err) < 5) {
            current_err = 0;
            pid_finetune_x.integral = 0;
        }
        
        // 精调阶段积分（更保守）
        pid_finetune_x.integral += current_err;
        if(pid_finetune_x.integral > 400) pid_finetune_x.integral = 400;
        else if(pid_finetune_x.integral < -400) pid_finetune_x.integral = -400;

        // 精调阶段微分
        float derivative = current_err - pid_finetune_x.last_err;

        x_pwm = pid_finetune_x.kp * current_err + pid_finetune_x.ki * pid_finetune_x.integral + pid_finetune_x.kd * derivative;

        // 精调阶段小输出限幅
        if(x_pwm > 300) x_pwm = 300;
        else if(x_pwm < -300) x_pwm = -300;
        
        // 慢响应时间，更稳定
        uint16_t response_time = 20;
        
        // 输出值计算
        now_x = ks2 + x_pwm;
        
        // PWM限幅
        if(now_x > 2200) now_x = 2200;
        else if(now_x < 800) now_x = 800;
        
        Servo_SetTarget(SERVO_X, now_x, response_time);
        
        // 显示精调状态
        OLED_ShowSignedNum(3,8,now_x,5);
    }
    
    // 更新上次误差
    pid_finetune_x.last_err = current_err;
}


// 重置PID控制器状态
void reset_pid_controllers(void) {
    // 重置PID_X控制器
    pid_x.integral = 0;
    pid_x.last_err = 0;
    
    // 重置搜索和精调控制器
    pid_search_x.integral = 0;
    pid_search_x.last_err = 0;
    pid_finetune_x.integral = 0;
    pid_finetune_x.last_err = 0;
    
    // 重置PID_Y控制器
    pid_y.integral = 0;
    pid_y.last_err = 0;
    
    // 重置任务3相关变量
    task3_stage = 0;
    stable_count = 0;
    last_stable_x = 0;
    target_found_time = 0;
    
    // 重置扫描搜索变量
    target_lost_count = 0;
    scan_direction = 1;
    scan_center = 160;
    scan_step_count = 0;
    
    // 重置运动预测变量
    last_target_x = 160;
    target_velocity_x = 0;
    
    // 重置输出值到中心位置
    now_x = 1500;
    now_y = 1500;
    x_pwm = 0;
    y_pwm = 0;

    Servo_SetTarget(SERVO_X, now_x, 5); // X轴专用：使用5ms超快响应时间
    OLED_ShowSignedNum(3,8,now_x,5);
}
```

